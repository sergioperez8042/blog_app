import { NextRequest, NextResponse } from 'next/server';
import { writeFile, readFile } from 'fs/promises';
import path from 'path';
import { PostStore, Post } from '@/lib/postStore';

interface ScheduledTopic {
  title: string;
  category: string;
}

// Scheduler autom√°tico para contenido diario
class AutoContentScheduler {
  private postsFile: string;
  private scheduledTopics: ScheduledTopic[];

  constructor() {
    this.postsFile = path.join(process.cwd(), 'data', 'posts.json');
    this.scheduledTopics = [
      // Tecnolog√≠a
      { title: 'Las mejores herramientas de IA para 2025', category: 'Technology' },
      { title: 'Tendencias en desarrollo web que debes conocer', category: 'Technology' },
      { title: 'Ciberseguridad: Protege tu negocio digital', category: 'Technology' },
      { title: 'Cloud Computing: Gu√≠a completa para empresas', category: 'Technology' },
      { title: 'Automatizaci√≥n de procesos con IA', category: 'Technology' },
      
      // Viajes
      { title: 'Destinos emergentes para viajeros aventureros', category: 'Travel' },
      { title: 'Viaje sostenible: C√≥mo reducir tu huella de carbono', category: 'Travel' },
      { title: 'Gu√≠a completa para n√≥madas digitales', category: 'Travel' },
      { title: 'Los mejores destinos para trabajar remotamente', category: 'Travel' },
      
      // Comida
      { title: 'Tendencias gastron√≥micas que marcar√°n el a√±o', category: 'Food' },
      { title: 'Cocina saludable: Recetas nutritivas y deliciosas', category: 'Food' },
      { title: 'Fermentaci√≥n casera: Gu√≠a para principiantes', category: 'Food' },
      
      // Moda
      { title: 'Moda sostenible: Marcas que est√°n cambiando el juego', category: 'Fashion' },
      { title: 'Tendencias de moda para la nueva temporada', category: 'Fashion' },
      
      // Cultura
      { title: 'Arte digital y NFTs: El futuro del coleccionismo', category: 'Culture' },
      { title: 'Festivales culturales que no puedes perderte', category: 'Culture' },
      { title: 'La influencia de las redes sociales en la cultura', category: 'Culture' }
    ];
  }

  async generateDailyContent() {
    try {
      console.log('ü§ñ Iniciando generaci√≥n de contenido diario...');
      
      // Seleccionar topic del d√≠a
      const today = new Date();
      const dayOfYear = Math.floor((today.getTime() - new Date(today.getFullYear(), 0, 0).getTime()) / (1000 * 60 * 60 * 24));
      const topicIndex = dayOfYear % this.scheduledTopics.length;
      const dailyTopic = this.scheduledTopics[topicIndex];

      console.log(`üìù Topic del d√≠a: ${dailyTopic.title}`);

      // Generar contenido usando IA h√≠brida directamente
      const contentData = await this.generateContentDirectly(dailyTopic.title, dailyTopic.category);
      
      // Crear post autom√°tico
      const newPost: Post = {
        id: Date.now().toString(),
        title: dailyTopic.title,
        category: dailyTopic.category,
        content: contentData.content,
        createdAt: new Date().toISOString(),
        author: 'AI Content Bot',
        isAutoGenerated: true,
        source: contentData.source,
        model: contentData.model,
        confidence: contentData.confidence
      };

      // Guardar post
      await this.savePost(newPost);
      
      console.log('‚úÖ Contenido diario generado y publicado exitosamente');
      
      return {
        success: true,
        post: newPost,
        message: 'Contenido diario generado autom√°ticamente'
      };

    } catch (error) {
      console.error('‚ùå Error en generaci√≥n autom√°tica:', error);
      throw error;
    }
  }

  async savePost(post: Post) {
    try {
      // En producci√≥n, usar almac√©n global
      // En desarrollo, usar archivos locales
      const isProduction = process.env.NODE_ENV === 'production';
      
      if (isProduction) {
        // Usar almac√©n global para producci√≥n
        PostStore.addPost(post);
        console.log('üíæ Post guardado exitosamente en almac√©n global (producci√≥n)');
        return;
      }
      
      // Leer posts existentes (solo en desarrollo)
      let posts: Post[] = [];
      try {
        const postsData = await readFile(this.postsFile, 'utf8');
        posts = JSON.parse(postsData);
      } catch (error) {
        // Si no existe el archivo, crear array vac√≠o
        posts = [];
      }

      // Agregar nuevo post al inicio
      posts.unshift(post);

      // Mantener solo los √∫ltimos 50 posts para no sobrecargar
      if (posts.length > 50) {
        posts = posts.slice(0, 50);
      }

      // Guardar posts actualizados
      await writeFile(this.postsFile, JSON.stringify(posts, null, 2));
      
      console.log('üíæ Post guardado exitosamente');
      
    } catch (error) {
      console.error('‚ùå Error guardando post:', error);
      // No lanzar error en producci√≥n para evitar fallos
      if (process.env.NODE_ENV !== 'production') {
        throw error;
      }
    }
  }

  async syncWithMainPosts(post: Post) {
    try {
      // Hacer una llamada interna a la API de posts para sincronizar
      const response = await fetch(`${process.env.VERCEL_URL ? `https://${process.env.VERCEL_URL}` : 'http://localhost:3000'}/api/posts`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          title: post.title,
          category: post.category,
          content: post.content,
          author: post.author,
          isAutoGenerated: post.isAutoGenerated
        }),
      });

      if (!response.ok) {
        console.error('Error sincronizando con posts principales');
      }
    } catch (error) {
      console.error('Error en sincronizaci√≥n:', error);
    }
  }

  async getScheduleStatus() {
    const today = new Date();
    const lastRun = await this.getLastRunDate();
    
    return {
      currentTime: today.toISOString(),
      lastRun: lastRun,
      nextRun: this.getNextRunTime(),
      isTimeToRun: this.shouldRunToday(lastRun),
      totalScheduledTopics: this.scheduledTopics.length
    };
  }

  async getLastRunDate(): Promise<string | null> {
    try {
      // En producci√≥n, usar almac√©n global
      if (process.env.NODE_ENV === 'production') {
        const autoPost = PostStore.getLastAutoGeneratedPost();
        return autoPost ? autoPost.createdAt : null;
      }
      
      const posts = await readFile(this.postsFile, 'utf8');
      const parsedPosts: Post[] = JSON.parse(posts);
      const autoPost = parsedPosts.find((post: Post) => post.isAutoGenerated);
      return autoPost ? autoPost.createdAt : null;
    } catch (error) {
      return null;
    }
  }

  getNextRunTime(): string {
    const tomorrow = new Date();
    tomorrow.setDate(tomorrow.getDate() + 1);
    tomorrow.setHours(9, 0, 0, 0); // 9:00 AM
    return tomorrow.toISOString();
  }

  shouldRunToday(lastRun: string | null): boolean {
    if (!lastRun) return true;
    
    const today = new Date();
    const lastRunDate = new Date(lastRun);
    
    // Si es despu√©s de las 9 AM y no se ha ejecutado hoy
    return today.getHours() >= 9 && 
           today.toDateString() !== lastRunDate.toDateString();
  }

  async generateContentDirectly(title: string, category: string) {
    try {
      // Implementar l√≥gica de generaci√≥n de contenido directa
      // Para evitar el problema de fetch, usaremos un generador mock mejorado
      const mockContent = this.generateMockContent(title, category);
      
      return {
        content: mockContent,
        source: 'AI Mock Generator',
        model: 'Local AI System',
        confidence: 0.85
      };
      
    } catch (error) {
      console.error('Error generando contenido:', error);
      throw error;
    }
  }

  generateMockContent(title: string, category: string): string {
    const intros = [
      `En el mundo actual de ${category.toLowerCase()}, ${title.toLowerCase()} se ha convertido en un tema crucial.`,
      `La evoluci√≥n constante en ${category.toLowerCase()} nos lleva a explorar ${title.toLowerCase()}.`,
      `${title} representa una tendencia importante en el sector de ${category.toLowerCase()}.`
    ];

    const bodies = [
      `Esta tendencia est√° transformando la manera en que abordamos los desaf√≠os modernos. Las innovaciones recientes han demostrado que es posible lograr resultados excepcionales cuando se aplican las estrategias correctas.`,
      `Los expertos en la materia coinciden en que este desarrollo marcar√° un antes y despu√©s en la industria. Las empresas que adopten estas pr√°cticas tempranamente tendr√°n una ventaja competitiva significativa.`,
      `La investigaci√≥n m√°s reciente indica que este enfoque puede generar beneficios tanto a corto como a largo plazo. Es fundamental comprender los aspectos clave para maximizar el potencial de esta oportunidad.`
    ];

    const conclusions = [
      `En conclusi√≥n, mantenerse actualizado con estas tendencias es esencial para el √©xito en el panorama actual.`,
      `El futuro parece prometedor para quienes sepan adaptarse a estos cambios y aprovechar las oportunidades que presentan.`,
      `La clave est√° en la implementaci√≥n cuidadosa y el monitoreo continuo de los resultados para asegurar el √©xito a largo plazo.`
    ];

    const randomIntro = intros[Math.floor(Math.random() * intros.length)];
    const randomBody = bodies[Math.floor(Math.random() * bodies.length)];
    const randomConclusion = conclusions[Math.floor(Math.random() * conclusions.length)];

    return `${randomIntro}\n\n${randomBody}\n\n${randomConclusion}`;
  }
}

// Endpoint para ejecutar manualmente
export async function POST(request: NextRequest) {
  try {
    const scheduler = new AutoContentScheduler();
    const result = await scheduler.generateDailyContent();
    
    return NextResponse.json(result);
    
  } catch (error: any) {
    console.error('Error en scheduler:', error);
    return NextResponse.json(
      { error: error.message, success: false },
      { status: 500 }
    );
  }
}

// Endpoint para verificar estado
export async function GET(request: NextRequest) {
  try {
    const scheduler = new AutoContentScheduler();
    const status = await scheduler.getScheduleStatus();
    
    return NextResponse.json(status);
    
  } catch (error: any) {
    return NextResponse.json(
      { error: error.message },
      { status: 500 }
    );
  }
}
