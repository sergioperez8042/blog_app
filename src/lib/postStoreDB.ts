import Post, { IPost } from '../models/Post';
import { connectDB } from './mongodb';
import { postEvents } from './events';

// Interfaz para mantener compatibilidad con el sistema anterior
export interface PostData {
  id: string;
  title: string;
  category: string;
  content: string;
  createdAt: string;
  author: string;
  isAutoGenerated?: boolean;
  source?: string;
  model?: string;
  confidence?: number;
  likes?: number;
}

// Función para convertir documento MongoDB a PostData
function mongoToPostData(doc: IPost): PostData {
  return {
    id: (doc._id as any).toString(),
    title: doc.title,
    category: doc.category,
    content: doc.content,
    createdAt: doc.createdAt.toISOString(),
    author: doc.author,
    isAutoGenerated: doc.isAutoGenerated,
    source: doc.source,
    model: doc.aiModel,
    confidence: doc.confidence,
    likes: doc.likes
  };
}

export class PostStore {
  // Obtener todos los posts
  static async getAllPosts(): Promise<PostData[]> {
    try {
      await connectDB();
      const posts = await Post.find().sort({ createdAt: -1 });
      return posts.map(mongoToPostData);
    } catch (error) {
      console.error('Error getting all posts:', error);
      return [];
    }
  }

  // Agregar un nuevo post
  static async addPost(postData: Omit<PostData, 'id'>): Promise<PostData | null> {
    try {
      await connectDB();
      const post = new Post({
        title: postData.title,
        category: postData.category,
        content: postData.content,
        author: postData.author,
        isAutoGenerated: postData.isAutoGenerated || false,
        source: postData.source,
        aiModel: postData.model,
        confidence: postData.confidence,
        likes: postData.likes || 0
      });
      
      const savedPost = await post.save();
      return mongoToPostData(savedPost);
    } catch (error) {
      console.error('Error adding post:', error);
      return null;
    }
  }

  // Obtener post por ID
  static async getPostById(id: string): Promise<PostData | null> {
    try {
      await connectDB();
      const post = await Post.findById(id);
      return post ? mongoToPostData(post) : null;
    } catch (error) {
      console.error('Error getting post by ID:', error);
      return null;
    }
  }

  // Obtener posts por categoría
  static async getPostsByCategory(category: string): Promise<PostData[]> {
    try {
      await connectDB();
      const posts = await Post.find({ category }).sort({ createdAt: -1 });
      return posts.map(mongoToPostData);
    } catch (error) {
      console.error('Error getting posts by category:', error);
      return [];
    }
  }

  // Obtener el post más reciente
  static async getLatestPost(): Promise<PostData | null> {
    try {
      await connectDB();
      const post = await Post.findOne().sort({ createdAt: -1 });
      return post ? mongoToPostData(post) : null;
    } catch (error) {
      console.error('Error getting latest post:', error);
      return null;
    }
  }

  // Obtener posts autogenerados
  static async getAutoGeneratedPosts(): Promise<PostData[]> {
    try {
      await connectDB();
      const posts = await Post.find({ isAutoGenerated: true }).sort({ createdAt: -1 });
      return posts.map(mongoToPostData);
    } catch (error) {
      console.error('Error getting auto-generated posts:', error);
      return [];
    }
  }

  // Obtener el último post autogenerado
  static async getLastAutoGeneratedPost(): Promise<PostData | null> {
    try {
      await connectDB();
      const post = await Post.findOne({ isAutoGenerated: true }).sort({ createdAt: -1 });
      return post ? mongoToPostData(post) : null;
    } catch (error) {
      console.error('Error getting last auto-generated post:', error);
      return null;
    }
  }

  // Dar like a un post
  static async likePost(postId: string): Promise<boolean> {
    try {
      await connectDB();
      const post = await Post.findById(postId);
      if (post) {
        post.likes += 1;
        await post.save();
        
        // Emitir evento para actualizar componentes
        postEvents.emit('likeUpdated', postId, post.likes);
        return true;
      }
      return false;
    } catch (error) {
      console.error('Error liking post:', error);
      return false;
    }
  }

  // Obtener el post más popular
  static async getMostPopularPost(): Promise<PostData | null> {
    try {
      await connectDB();
      const post = await Post.findOne().sort({ likes: -1, createdAt: -1 });
      return post ? mongoToPostData(post) : null;
    } catch (error) {
      console.error('Error getting most popular post:', error);
      return null;
    }
  }

  // Obtener posts ordenados por likes
  static async getPostsOrderedByLikes(): Promise<PostData[]> {
    try {
      await connectDB();
      const posts = await Post.find().sort({ likes: -1, createdAt: -1 });
      return posts.map(mongoToPostData);
    } catch (error) {
      console.error('Error getting posts ordered by likes:', error);
      return [];
    }
  }

  // Obtener posts más recientes
  static async getLatestPosts(limit: number = 5): Promise<PostData[]> {
    try {
      await connectDB();
      const posts = await Post.find().sort({ createdAt: -1 }).limit(limit);
      return posts.map(mongoToPostData);
    } catch (error) {
      console.error('Error getting latest posts:', error);
      return [];
    }
  }

  // Actualizar un post
  static async updatePost(id: string, updates: Partial<PostData>): Promise<PostData | null> {
    try {
      await connectDB();
      const updateData: any = {};
      
      if (updates.title) updateData.title = updates.title;
      if (updates.category) updateData.category = updates.category;
      if (updates.content) updateData.content = updates.content;
      if (updates.author) updateData.author = updates.author;
      if (updates.isAutoGenerated !== undefined) updateData.isAutoGenerated = updates.isAutoGenerated;
      if (updates.source) updateData.source = updates.source;
      if (updates.model) updateData.aiModel = updates.model;
      if (updates.confidence !== undefined) updateData.confidence = updates.confidence;
      if (updates.likes !== undefined) updateData.likes = updates.likes;
      
      const post = await Post.findByIdAndUpdate(id, updateData, { new: true });
      return post ? mongoToPostData(post) : null;
    } catch (error) {
      console.error('Error updating post:', error);
      return null;
    }
  }

  // Eliminar un post
  static async deletePost(id: string): Promise<boolean> {
    try {
      await connectDB();
      const result = await Post.findByIdAndDelete(id);
      return result !== null;
    } catch (error) {
      console.error('Error deleting post:', error);
      return false;
    }
  }

  // Obtener estadísticas
  static async getStats(): Promise<{
    totalPosts: number;
    totalLikes: number;
    autoGeneratedPosts: number;
    manualPosts: number;
  }> {
    try {
      await connectDB();
      const totalPosts = await Post.countDocuments();
      const autoGeneratedPosts = await Post.countDocuments({ isAutoGenerated: true });
      const manualPosts = totalPosts - autoGeneratedPosts;
      
      const likesResult = await Post.aggregate([
        { $group: { _id: null, totalLikes: { $sum: '$likes' } } }
      ]);
      
      const totalLikes = likesResult.length > 0 ? likesResult[0].totalLikes : 0;
      
      return {
        totalPosts,
        totalLikes,
        autoGeneratedPosts,
        manualPosts
      };
    } catch (error) {
      console.error('Error getting stats:', error);
      return {
        totalPosts: 0,
        totalLikes: 0,
        autoGeneratedPosts: 0,
        manualPosts: 0
      };
    }
  }
}
