// Importar PostStore con base de datos
import { PostStore as PostStoreDB, PostData } from './postStoreDB';
import { PostStoreFallback } from './postStoreFallback';
import { postEvents } from './events';

// Verificar si MongoDB está disponible
function isMongoDBConfigured(): boolean {
  return !!process.env.MONGODB_URI;
}

// Interfaz para compatibilidad
export interface Post {
  id: string;
  title: string;
  category: string;
  content: string;
  createdAt: string;
  author: string;
  isAutoGenerated?: boolean;
  source?: string;
  model?: string;
  confidence?: number;
  likes?: number;
}

// Clase PostStore que delega a la base de datos o fallback
export class PostStore {
  static async getAllPosts(): Promise<Post[]> {
    try {
      if (isMongoDBConfigured()) {
        return await PostStoreDB.getAllPosts();
      } else {
        console.log('⚠️  Usando PostStoreFallback - MongoDB no configurado');
        return await PostStoreFallback.getAllPosts();
      }
    } catch (error) {
      console.error('Error getting all posts:', error);
      // Fallback en caso de error
      return await PostStoreFallback.getAllPosts();
    }
  }

  static async addPost(post: Post): Promise<Post | null> {
    try {
      // Convertir Post a PostData sin el id para PostStoreDB
      const postData = {
        title: post.title,
        category: post.category,
        content: post.content,
        createdAt: post.createdAt,
        author: post.author,
        isAutoGenerated: post.isAutoGenerated,
        source: post.source,
        model: post.model,
        confidence: post.confidence,
        likes: post.likes
      };
      
      if (isMongoDBConfigured()) {
        const savedPost = await PostStoreDB.addPost(postData);
        return savedPost;
      } else {
        console.log('⚠️  Usando PostStoreFallback - MongoDB no configurado');
        return await PostStoreFallback.addPost(postData);
      }
    } catch (error) {
      console.error('Error adding post:', error);
      // Fallback en caso de error
      try {
        const postData = {
          title: post.title,
          category: post.category,
          content: post.content,
          createdAt: post.createdAt,
          author: post.author,
          isAutoGenerated: post.isAutoGenerated,
          source: post.source,
          model: post.model,
          confidence: post.confidence,
          likes: post.likes
        };
        return await PostStoreFallback.addPost(postData);
      } catch (fallbackError) {
        console.error('Error en fallback:', fallbackError);
        return null;
      }
    }
  }

  static async getPostById(id: string): Promise<Post | undefined> {
    try {
      const post = await PostStoreDB.getPostById(id);
      return post || undefined;
    } catch (error) {
      console.error('Error getting post by ID:', error);
      return undefined;
    }
  }

  static async getPostsByCategory(category: string): Promise<Post[]> {
    try {
      return await PostStoreDB.getPostsByCategory(category);
    } catch (error) {
      console.error('Error getting posts by category:', error);
      return [];
    }
  }

  static async getLatestPost(): Promise<Post | undefined> {
    try {
      const post = await PostStoreDB.getLatestPost();
      return post || undefined;
    } catch (error) {
      console.error('Error getting latest post:', error);
      return undefined;
    }
  }

  static async getAutoGeneratedPosts(): Promise<Post[]> {
    try {
      return await PostStoreDB.getAutoGeneratedPosts();
    } catch (error) {
      console.error('Error getting auto-generated posts:', error);
      return [];
    }
  }

  static async getLastAutoGeneratedPost(): Promise<Post | undefined> {
    try {
      if (isMongoDBConfigured()) {
        const post = await PostStoreDB.getLastAutoGeneratedPost();
        return post ? post : undefined;
      } else {
        console.log('⚠️  Usando PostStoreFallback - MongoDB no configurado');
        const post = await PostStoreFallback.getLastAutoGeneratedPost();
        return post ? post : undefined;
      }
    } catch (error) {
      console.error('Error getting last auto-generated post:', error);
      // Fallback en caso de error
      try {
        const post = await PostStoreFallback.getLastAutoGeneratedPost();
        return post ? post : undefined;
      } catch (fallbackError) {
        console.error('Error en fallback:', fallbackError);
        return undefined;
      }
    }
  }

  static async likePost(postId: string): Promise<boolean> {
    try {
      return await PostStoreDB.likePost(postId);
    } catch (error) {
      console.error('Error liking post:', error);
      return false;
    }
  }

  static async getMostPopularPost(): Promise<Post | undefined> {
    try {
      const post = await PostStoreDB.getMostPopularPost();
      return post || undefined;
    } catch (error) {
      console.error('Error getting most popular post:', error);
      return undefined;
    }
  }

  static async getPostsOrderedByLikes(): Promise<Post[]> {
    try {
      return await PostStoreDB.getPostsOrderedByLikes();
    } catch (error) {
      console.error('Error getting posts ordered by likes:', error);
      return [];
    }
  }

  static async getLatestPosts(limit: number = 5): Promise<Post[]> {
    try {
      return await PostStoreDB.getLatestPosts(limit);
    } catch (error) {
      console.error('Error getting latest posts:', error);
      return [];
    }
  }

  static async updatePost(id: string, updates: Partial<Post>): Promise<Post | null> {
    try {
      const updatedPost = await PostStoreDB.updatePost(id, updates);
      return updatedPost;
    } catch (error) {
      console.error('Error updating post:', error);
      return null;
    }
  }

  static async deletePost(id: string): Promise<boolean> {
    try {
      const deleted = await PostStoreDB.deletePost(id);
      return deleted;
    } catch (error) {
      console.error('Error deleting post:', error);
      return false;
    }
  }
}
